<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shubham Sachdeva Blog</title>
    <link>https://gamehacker1999.github.io/</link>
    <description>Recent content on Shubham Sachdeva Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 May 2021 15:04:20 -0400</lastBuildDate><atom:link href="https://gamehacker1999.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Distributing Monte Carlo errors as Blue Noise in Screen Space, Part 2 - Retargeting Pass</title>
      <link>https://gamehacker1999.github.io/posts/retargetingpass/</link>
      <pubDate>Thu, 20 May 2021 15:04:20 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/retargetingpass/</guid>
      <description>In the last part of this series, I talked about the theory presented in [1] as well talked about how and why we should implement the sorting pass in order to redistribute the seeds using a dithering tile so that we can distribute the monte carlo errors in real time applications as blue noise in screen space. In this part I want to talk about the shortcomings of just using the sorting pass and how we can retarget seeds between frames in order to accumulate and improve our results over frames.</description>
    </item>
    
    <item>
      <title>Distributing Monte Carlo errors as Blue Noise in Screen Space, Part 1 - Theory and Sorting</title>
      <link>https://gamehacker1999.github.io/posts/bluenoiseerrors/</link>
      <pubDate>Thu, 18 Mar 2021 15:04:20 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/bluenoiseerrors/</guid>
      <description>Many of us have written a monte carlo raytracer. One of the key results is that the results are extremely noisy, and are usually distributed as white noise in screen space. In order to mitigate this, the usual convention is to increase the number of samples per pixel in order to make the image converge to ground truth. This, however, isn&amp;rsquo;t really possible for real-time applications like games which usually have a target of 16ms per frame.</description>
    </item>
    
  </channel>
</rss>
