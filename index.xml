<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shubham Sachdeva Blog</title>
    <link>https://gamehacker1999.github.io/</link>
    <description>Recent content on Shubham Sachdeva Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Apr 2022 16:04:30 -0400</lastBuildDate><atom:link href="https://gamehacker1999.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dynamic, Noise Free, Screen Space Diffuse Global Illumination</title>
      <link>https://gamehacker1999.github.io/posts/ssgi/</link>
      <pubDate>Fri, 22 Apr 2022 16:04:30 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/ssgi/</guid>
      <description>Getting Dynamic Real-Time diffuse global illumination is still an open problem. Recent developments by McGuire et al.[1] and Lumen in Unreal Engine 5 seem to provide believable real time global illumination. However these methods are very expensive and cannot support lower or even mid ranged hardware, or do so with significant performance costs. Even so, we have seen both of these technologies in action, Metro Exodus: Enhanced Edition used a version of the DDGI solution and the UE5 demos &amp;ldquo;Lumen in the land of Nanite&amp;rdquo; and &amp;ldquo;The Matrix Awakens&amp;rdquo; both ran Lumen alongside their fantastic micropolygon geomtry solution Nanite[2].</description>
    </item>
    
    <item>
      <title>Spatiotemporal Reservoir Resampling (ReSTIR) - Theory and Basic Implementation</title>
      <link>https://gamehacker1999.github.io/posts/restir/</link>
      <pubDate>Mon, 23 Aug 2021 16:17:43 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/restir/</guid>
      <description>Real time raytracing has become very popular in the last year or so, especially with the release of current generation of consoles which has made it more accessible to people. Even then, raytracing in real time is far slower than rasterization and we are only able to afford very few samples per pixel. This leads to very noisy results, which usually requires a spatio temporal denoising pass. One such domain which can produce noisy results is raytracing direct lighting when there are thousands, or even millions of light sources, which can range from simple point lights, all the way to complex mesh lights.</description>
    </item>
    
    <item>
      <title>Distributing Monte Carlo errors as Blue Noise in Screen Space, Part 2 - Retargeting Pass</title>
      <link>https://gamehacker1999.github.io/posts/retargetingpass/</link>
      <pubDate>Thu, 20 May 2021 15:04:20 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/retargetingpass/</guid>
      <description>In the last part of this series, I talked about the theory presented in [1] as well talked about how and why we should implement the sorting pass in order to redistribute the seeds using a dithering tile so that we can distribute the monte carlo errors in real time applications as blue noise in screen space. In this part I want to talk about the shortcomings of just using the sorting pass and how we can retarget seeds between frames in order to accumulate and improve our results over frames.</description>
    </item>
    
    <item>
      <title>Distributing Monte Carlo errors as Blue Noise in Screen Space, Part 1 - Theory and Sorting</title>
      <link>https://gamehacker1999.github.io/posts/bluenoiseerrors/</link>
      <pubDate>Thu, 18 Mar 2021 15:04:20 -0400</pubDate>
      
      <guid>https://gamehacker1999.github.io/posts/bluenoiseerrors/</guid>
      <description>Many of us have written a monte carlo raytracer. One of the key results is that the results are extremely noisy, and are usually distributed as white noise in screen space. In order to mitigate this, the usual convention is to increase the number of samples per pixel in order to make the image converge to ground truth. This, however, isn&amp;rsquo;t really possible for real-time applications like games which usually have a target of 16ms per frame.</description>
    </item>
    
  </channel>
</rss>
